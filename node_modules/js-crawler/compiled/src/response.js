"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const _ = require("underscore");
const BODY_PLACEHOLDER = '<<...non-text content (omitted by js-crawler)...>>';
class Response {
    constructor(response) {
        this.response = response;
    }
    isTextHtml() {
        const { response } = this;
        const isContentTypeHeaderDefined = Boolean(response && response.headers && response.headers['content-type']);
        return isContentTypeHeaderDefined && response.headers['content-type'].startsWith('text/html');
    }
    decode(encoded, encoding) {
        const defaultEncoding = 'utf8';
        if (!encoding) {
            encoding = defaultEncoding;
        }
        let decodedBody;
        try {
            decodedBody = encoded.toString(encoding);
        }
        catch (decodingError) {
            decodedBody = encoded.toString(defaultEncoding);
        }
        return decodedBody;
    }
    getBody() {
        if (!this.isTextHtml()) {
            return BODY_PLACEHOLDER;
        }
        const { response } = this;
        const encoding = response.headers['content-encoding'];
        return this.decode(response.body, encoding);
    }
    stripComments(str) {
        return str.replace(/<!--.*?-->/g, '');
    }
    getBaseUrl(responseUrl, body) {
        /*
         * Resolving the base url following
         * the algorithm from https://www.w3.org/TR/html5/document-metadata.html#the-base-element
         */
        const baseUrlRegex = /<base href="(.*?)">/;
        const baseUrlInPage = body.match(baseUrlRegex);
        if (!baseUrlInPage) {
            return responseUrl;
        }
        const baseUrl = baseUrlInPage[1];
        return url_1.resolve(responseUrl, baseUrl);
    }
    ;
    isUrlProtocolSupported(link) {
        return link.startsWith('http://') || link.startsWith('https://');
    }
    getHrefFrom(linkHtml) {
        const match = /href=[\"\'](.*?)[#\"\']/i.exec(linkHtml);
        return match[1];
    }
    getAllUrls(responseUrl, body, behavior) {
        if (!this.isTextHtml()) {
            return [];
        }
        body = this.stripComments(body);
        const baseUrl = this.getBaseUrl(responseUrl, body);
        const linksRegex = behavior.ignoreRelative ? /<a[^>]+?href=["'].*?:\/\/.*?["']/gmi : /<a[^>]+?href=["'].*?["']/gmi;
        const links = body.match(linksRegex) || [];
        //console.log('body = ', body);
        const urls = _.chain(links)
            .map(link => url_1.resolve(baseUrl, this.getHrefFrom(link)))
            .uniq()
            .filter(link => this.isUrlProtocolSupported(link) && behavior.shouldCrawl(link))
            .value();
        //console.log('urls to crawl = ', urls);
        return urls;
    }
    ;
}
exports.default = Response;
//# sourceMappingURL=response.js.map