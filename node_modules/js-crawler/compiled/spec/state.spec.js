"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const state_1 = require("../src/state");
const _ = require('underscore');
const sinon = require("sinon");
const chai_1 = require("chai");
describe('state', () => {
    const urls = [
        'url1',
        'url2',
        'url3'
    ];
    const [url1, url2, url3] = urls;
    let state;
    let onCrawlingFinished;
    beforeEach(() => {
        onCrawlingFinished = sinon.spy();
        state = new state_1.default({ onCrawlingFinished });
    });
    describe('empty state', () => {
        it('should have empty fields', () => {
            chai_1.expect(Object.keys(state.visitedUrls)).to.be.empty;
            chai_1.expect(Object.keys(state.crawledUrls)).to.be.empty;
            chai_1.expect(state.beingCrawledUrls).to.be.empty;
        });
    });
    describe('startedCrawling & isBeingCrawled', () => {
        it('should add url to list or urls being crawled', () => {
            chai_1.expect(state.isBeingCrawled(url1)).to.be.false;
            state.startedCrawling(url1);
            chai_1.expect(state.isBeingCrawled(url1)).to.be.true;
            chai_1.expect(state.beingCrawledUrls).to.eql([url1]);
        });
        it('should not store duplicates or urls being crawled', () => {
            state.startedCrawling(url1);
            state.startedCrawling(url1);
            state.startedCrawling(url1);
            chai_1.expect(state.isBeingCrawled(url1)).to.be.true;
            chai_1.expect(state.beingCrawledUrls).to.eql([url1]);
        });
    });
    describe('addVisitedUrls & isVisitedUrl', () => {
        it('should add all urls to the list of visited urls', () => {
            chai_1.expect(state.isVisitedUrl(url1)).to.be.false;
            chai_1.expect(state.isVisitedUrl(url2)).to.be.false;
            chai_1.expect(state.isVisitedUrl(url3)).to.be.false;
            state.rememberVisitedUrls([url1, url2]);
            chai_1.expect(state.isVisitedUrl(url1)).to.be.true;
            chai_1.expect(state.isVisitedUrl(url2)).to.be.true;
            chai_1.expect(state.isVisitedUrl(url3)).to.be.false;
            chai_1.expect(state.visitedUrls).to.eql({
                [url1]: true,
                [url2]: true
            });
        });
    });
    describe('addCrawledUrl & isVisitedUrl', () => {
        it('should add url to the list of visited urls and crawled urls', () => {
            chai_1.expect(state.isVisitedUrl(url1)).to.be.false;
            chai_1.expect(state.isVisitedUrl(url2)).to.be.false;
            state.rememberCrawledUrl(url1);
            chai_1.expect(state.isVisitedUrl(url1)).to.be.true;
            chai_1.expect(state.isVisitedUrl(url2)).to.be.false;
            chai_1.expect(state.visitedUrls).to.eql({
                [url1]: true
            });
            chai_1.expect(state.crawledUrls).to.eql({
                [url1]: true
            });
        });
    });
    describe('finishedCrawling', () => {
        it('should be called when the only url was crawled', () => {
            state.startedCrawling(url1);
            state.rememberCrawledUrl(url1);
            state.finishedCrawling(url1);
            chai_1.expect(onCrawlingFinished.calledWith([url1])).to.be.true;
        });
        it('should not call onCrawlingFinished when there are urls being crawled', () => {
            state.startedCrawling(url1);
            state.startedCrawling(url2);
            state.rememberCrawledUrl(url1);
            state.finishedCrawling(url1);
            chai_1.expect(onCrawlingFinished.callCount).to.eql(0);
        });
        it('should be called when all urls were crawled', () => {
            urls.forEach(url => {
                state.startedCrawling(url);
                state.rememberCrawledUrl(url);
                state.finishedCrawling(url);
            });
            chai_1.expect(onCrawlingFinished.calledWith(urls)).to.be.true;
        });
        it('should call onCrawlingFinished when urls have redirects', () => {
            // full redirect chain redirect1 -> redirect2 -> redirect3 -> url1
            const redirectUrls = ['redirect1', 'redirect2', 'redirect3', url1];
            state.startedCrawling('redirect1');
            state.rememberVisitedUrls(redirectUrls);
            state.rememberCrawledUrl(url1);
            state.finishedCrawling('redirect1');
            chai_1.expect(onCrawlingFinished.calledWith([url1])).to.be.true;
        });
        it('should ignore finishedCrawling if url is not being actively crawled', () => {
            state.finishedCrawling(url1);
            chai_1.expect(state.beingCrawledUrls).to.eql([]);
        });
    });
});
//# sourceMappingURL=state.spec.js.map