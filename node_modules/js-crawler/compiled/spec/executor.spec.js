"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const executor_1 = require("../src/executor");
const chai_1 = require("chai");
const util_1 = require("./util/util");
describe('executor', () => {
    const executorOptions = {
        maxRatePerSecond: 5,
        maxConcurrentTasks: 10
    };
    const values = [1, 2, 3, 4];
    let producedValues;
    let executor;
    beforeEach(() => {
        executor = new executor_1.default(executorOptions);
        producedValues = [];
    });
    function getSubmittedTaskHandles(task) {
        let promiseResolves = [];
        values.forEach(value => {
            const promise = new Promise((resolve, reject) => {
                promiseResolves.push(resolve);
            });
            executor.submit(() => {
                task(value);
                return promise;
            });
        });
        return promiseResolves;
    }
    function submitTasks(task) {
        const resolves = getSubmittedTaskHandles(task);
        resolves.forEach(resolve => resolve());
    }
    describe('task execution', () => {
        it('should execute submitted tasks', (done) => {
            submitTasks(value => {
                producedValues.push(value);
            });
            executor.start();
            util_1.waitForCondition(() => executor.queue.length == 0).then(() => {
                chai_1.expect(producedValues).to.eql(values);
                executor.stop();
                done();
            });
        });
        it('should stop executing new tasks when maxConcurrentTasks has been reached', (done) => {
            executor = new executor_1.default(Object.assign(executorOptions, { maxConcurrentTasks: 2 }));
            const taskResolves = getSubmittedTaskHandles(value => {
                producedValues.push(value);
            });
            executor.start();
            util_1.waitForCondition(() => executor.queue.length == 2).then(() => {
                chai_1.expect(producedValues).to.eql(values.slice(0, 2));
                taskResolves.forEach(resolve => resolve());
                return util_1.waitForCondition(() => executor.queue.length == 0);
            }).then(() => {
                chai_1.expect(producedValues).to.eql(values);
                done();
            });
        });
        it('should stop executing tasks when stopped', (done) => {
            submitTasks(value => {
                producedValues.push(value);
            });
            executor.stop();
            executor.processQueueItem();
            util_1.waitForSomeTime().then(() => {
                chai_1.expect(executor.queue.length).to.eql(values.length);
                done();
            });
        });
        it('continuously executes tasks until explicitly stopped', (done) => {
            submitTasks(value => {
                producedValues.push(value);
                executor.stop();
            });
            executor.start();
            util_1.waitForSomeTime().then(() => {
                chai_1.expect(executor.queue.length).to.eql(values.length - 1);
                chai_1.expect(producedValues).to.eql(values.slice(0, 1));
                done();
            });
        });
    });
});
//# sourceMappingURL=executor.spec.js.map