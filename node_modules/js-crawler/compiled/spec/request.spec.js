"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = require("../src/request");
const _ = require('underscore');
const sinon = require("sinon");
const chai_1 = require("chai");
describe('request', () => {
    const referer = 'referer';
    const url = 'url';
    const redirectDestinationUrl = 'redirectDestinationUrl';
    const userAgent = 'userAgent';
    const requestOptions = {
        referer,
        url,
        userAgent
    };
    let request;
    let mockHttpClient;
    let callbackContext;
    let error;
    let response;
    let receivedRequestOptions;
    beforeEach(() => {
        callbackContext = {
            _redirect: {
                redirects: []
            }
        };
        error = null;
        response = {
            headers: {},
            body: {
                toString: (encoding) => ''
            },
            statusCode: 200,
            request: {
                uri: {
                    href: url
                }
            }
        };
        mockHttpClient = sinon.stub().callsFake((options, callback) => {
            callback.call(callbackContext, error, response);
            receivedRequestOptions = options;
        });
        request = new request_1.default(requestOptions, mockHttpClient);
    });
    describe('success response', () => {
        it('should provide correct request options', () => {
            const expectedOptions = {
                url: url,
                encoding: null,
                rejectUnauthorized: false,
                followRedirect: true,
                followAllRedirects: true,
                headers: {
                    'User-Agent': userAgent,
                    'Referer': referer
                }
            };
            return request.submit().then(() => {
                chai_1.expect(receivedRequestOptions).to.eql(expectedOptions);
            });
        });
        it('submit should resolve to RequestSuccess', () => {
            const expectedRequestSuccess = {
                visitedUrls: [url],
                lastVisitedUrl: url,
                response
            };
            return request.submit().then((requestSuccess) => {
                chai_1.expect(requestSuccess).to.eql(expectedRequestSuccess);
            });
        });
        describe('redirects', () => {
            it('should include redirect urls', () => {
                callbackContext._redirect.redirects = [
                    { redirectUri: 'url1' }, { redirectUri: 'url2' }, { redirectUri: 'url3' }
                ];
                response.request.uri.href = redirectDestinationUrl;
                const expectedRequestSuccess = {
                    visitedUrls: ['url1', 'url2', 'url3', url, redirectDestinationUrl],
                    lastVisitedUrl: url,
                    response
                };
                return request.submit().then((requestSuccess) => {
                    chai_1.expect(requestSuccess.visitedUrls).to.eql(expectedRequestSuccess.visitedUrls);
                });
            });
        });
    });
    describe('request failure', () => {
        beforeEach(() => {
            error = "Error that happened during request";
            response.statusCode = 404;
        });
        it('should reject with RequestFailure', () => {
            const expectedRequestFailure = {
                error,
                response
            };
            return request.submit().catch((requestFailure) => {
                chai_1.expect(requestFailure).to.eql(expectedRequestFailure);
            });
        });
    });
});
//# sourceMappingURL=request.spec.js.map