"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sinon = require("sinon");
exports.waitForCondition = (condition, options = { checkTimeoutMilliseconds: 10, maxTimeWaitedMilliseconds: 1000 }) => {
    const startTime = new Date().getTime();
    return new Promise((resolve, reject) => {
        setTimeout(function check() {
            if (condition()) {
                resolve();
            }
            else {
                const currentTime = new Date().getTime();
                const elapsedTime = currentTime - startTime;
                if (elapsedTime > options.maxTimeWaitedMilliseconds) {
                    reject(`Timeout waiting for condition ${condition.toString()}`);
                }
                else {
                    setTimeout(check, options.checkTimeoutMilliseconds);
                }
            }
        }, options.checkTimeoutMilliseconds);
    });
};
exports.waitForSomeTime = (timeoutMilliseconds = 100) => {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, timeoutMilliseconds);
    });
};
exports.textResponse = (url, statusCode, body) => ({
    headers: {
        'content-type': 'text/html'
    },
    body: {
        toString(encoding) {
            return body;
        }
    },
    statusCode: statusCode,
    request: {
        uri: {
            href: url
        }
    }
});
exports.immediateExecutor = {
    start: () => { },
    submit: (task) => {
        task();
    },
    stop: () => { }
};
exports.interceptAfter = (obj, method, interceptorMethod) => {
    const originalMethod = obj[method];
    const fakeMethod = sinon.stub();
    obj[method] = fakeMethod;
    fakeMethod.callsFake((...args) => {
        originalMethod.apply(obj, args);
        interceptorMethod.apply(null, args);
    });
};
//# sourceMappingURL=util.js.map